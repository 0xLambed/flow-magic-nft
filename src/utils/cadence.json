{"transactions":{"admin_mint_cars":"import NonFungibleToken from 0xNonFungibleToken\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport NewFunThing from 0xNewFunThing\nimport ProjectManager from 0xProjectManager\n\ntransaction(recipient: Address, packID: UInt64, metadatas: [{String: String}]) {\n    let manager: &ProjectManager.Manager\n    prepare(acct: AuthAccount) {\n        self.manager = acct.borrow<&ProjectManager.Manager>(from: ProjectManager.ManagerStoragePath)!\n    }\n\n    execute {\n        assert(metadatas.length > 0, message: \"No quantity provided.\")\n        for metadata in metadatas {\n            let car <- self.manager.mintSequentialNewFunThing(packID: packID)\n\n            let updatedMetadata = NewFunThing.getEditionMetadata(UInt64(car.id))\n            for key in metadata.keys {\n                updatedMetadata[key] = metadata[key]\n            }\n            self.manager.updateNewFunThingEditionMetadata(editionNumber: UInt64(car.id), metadata: updatedMetadata)\n        \n            getAccount(recipient).getCapability<&{NonFungibleToken.Receiver}>(NewFunThing.CollectionPublicPath).borrow()!.deposit(token: <-car)\n        }\n    }\n}","admin_mint_packs":"import NonFungibleToken from 0xNonFungibleToken\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport NewFunThingPack from 0xNewFunThingPack\nimport ProjectManager from 0xProjectManager\n\ntransaction(recipient: Address, packID: UInt64) {\n    let manager: &ProjectManager.Manager\n\n    prepare(acct: AuthAccount) {\n        self.manager = acct.borrow<&ProjectManager.Manager>(from: ProjectManager.ManagerStoragePath)!\n    }\n\n    execute {\n        let pack <- self.manager.mintSequentialNewFunThingPack(packID: packID)\n\n        getAccount(recipient).getCapability<&{NonFungibleToken.Receiver}>(NewFunThingPack.CollectionPublicPath).borrow()!.deposit(token: <- pack)\n    }\n}\n","admin_update_pack_edition_metadata":"import NonFungibleToken from 0xNonFungibleToken\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport NewFunThingPack from 0xNewFunThingPack\nimport ProjectManager from 0xProjectManager\n\ntransaction(editionNumber: Int, metadata: {String: String}) {\n    let manager: &ProjectManager.Manager\n    prepare(acct: AuthAccount) {\n        self.manager = acct.borrow<&ProjectManager.Manager>(from: ProjectManager.ManagerStoragePath)!\n    }\n\n    execute {\n        let updatedMetadata = NewFunThingPack.getEditionMetadata(UInt64(editionNumber))\n        for key in metadata.keys {\n            updatedMetadata[key] = metadata[key]\n        }\n        self.manager.updatePackEditionMetadata(editionNumber: UInt64(editionNumber), metadata: updatedMetadata)\n    }\n}\n","admin_update_token_edition_metadata":"import NonFungibleToken from 0xNonFungibleToken\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport NewFunThing from 0xNewFunThing\nimport ProjectManager from 0xProjectManager\n\ntransaction(editionNumber: Int, metadata: {String: String}) {\n    let manager: &ProjectManager.Manager\n    prepare(acct: AuthAccount) {\n        self.manager = acct.borrow<&ProjectManager.Manager>(from: ProjectManager.ManagerStoragePath)!\n    }\n\n    execute {\n        let updatedMetadata = NewFunThing.getEditionMetadata(UInt64(editionNumber))\n        for key in metadata.keys {\n            updatedMetadata[key] = metadata[key]\n        }\n        self.manager.updateNewFunThingEditionMetadata(editionNumber: UInt64(editionNumber), metadata: updatedMetadata)\n    }\n}\n","claim_pack":"import NonFungibleToken from 0xNonFungibleToken\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport NewFunThingPack from 0xNewFunThingPack\nimport ProjectManager from 0xProjectManager\n\ntransaction(recipient: Address, couponCode: String) {\n    let manager: &ProjectManager.Manager\n\n    prepare(acct: AuthAccount) {\n        self.manager = acct.borrow<&ProjectManager.Manager>(from: ProjectManager.ManagerStoragePath)!\n    }\n\n    execute {\n        self.manager.claimPack(recipient: recipient, couponCode: couponCode)\n    }\n}\n","redeem_pack":"import NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport NewFunThing from 0xNewFunThing\nimport NewFunThingPack from 0xNewFunThingPack\nimport ProjectManager from 0xProjectManager\n\ntransaction(packID: UInt64) {\n    let packToRedeem: @NonFungibleToken.NFT\n    let address: Address\n    \n    prepare(acct: AuthAccount) {\n        // Setup trait collection if they aren't already setup\n        if acct.borrow<&NewFunThing.Collection>(from: NewFunThing.CollectionStoragePath) == nil {\n            let collection <- NewFunThing.createEmptyCollection()\n            acct.save(<-collection, to: NewFunThing.CollectionStoragePath)\n        }\n        if acct.getCapability<&NewFunThing.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, NewFunThing.NewFunThingCollectionPublic, MetadataViews.ResolverCollection}>(NewFunThing.CollectionPublicPath).borrow() == nil {\n            acct.link<&NewFunThing.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, NewFunThing.NewFunThingCollectionPublic, MetadataViews.ResolverCollection}>(NewFunThing.CollectionPublicPath, target: NewFunThing.CollectionStoragePath)\n        }\n        self.packToRedeem <- acct.borrow<&{NonFungibleToken.Provider}>(from: NewFunThing.CollectionStoragePath)!.withdraw(withdrawID: packID)\n        self.address = acct.address\n    }\n\n    execute {\n        // Call public redeem method\n        ProjectManager.publicRedeemPack(pack: <-self.packToRedeem, address: self.address)\n    }\n}","setup_project_collections":"import NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport NewFunThing from 0xNewFunThing\nimport NewFunThingPack from 0xNewFunThingPack\n\n\ntransaction() {\n    \n    prepare(acct: AuthAccount) {\n        if acct.borrow<&NewFunThing.Collection>(from: NewFunThing.CollectionStoragePath) == nil {\n            let collection <- NewFunThing.createEmptyCollection()\n            acct.save(<-collection, to: NewFunThing.CollectionStoragePath)\n        }\n        if acct.getCapability<&NewFunThing.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, NewFunThing.NewFunThingCollectionPublic, MetadataViews.ResolverCollection}>(NewFunThing.CollectionPublicPath).borrow() == nil {\n            acct.link<&NewFunThing.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, NewFunThing.NewFunThingCollectionPublic, MetadataViews.ResolverCollection}>(NewFunThing.CollectionPublicPath, target: NewFunThing.CollectionStoragePath)\n        }\n\n        if acct.borrow<&NewFunThingPack.Collection>(from: NewFunThingPack.CollectionStoragePath) == nil {\n            let collection <- NewFunThingPack.createEmptyCollection()\n            acct.save(<-collection, to: NewFunThingPack.CollectionStoragePath)\n        }\n        if acct.getCapability<&NewFunThingPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, NewFunThingPack.PackCollectionPublic, MetadataViews.ResolverCollection}>(NewFunThingPack.CollectionPublicPath).borrow() == nil {\n            acct.link<&NewFunThingPack.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, NewFunThingPack.PackCollectionPublic, MetadataViews.ResolverCollection}>(NewFunThingPack.CollectionPublicPath, target: NewFunThingPack.CollectionStoragePath)\n        }\n    }\n    execute {\n    }\n}"},"scripts":{"get_NFT_pack_collection_metadata":"import NonFungibleToken from 0xNonFungibleToken\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport NewFunThingPack from 0xNewFunThingPack\n\npub fun main(): {String: String} {\n    return NewFunThingPack.getCollectionMetadata()\n}","get_NFT_pack_edition_metadata":"import NonFungibleToken from 0xNonFungibleToken\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport NewFunThingPack from 0xNewFunThingPack\n\npub fun main(edition: UInt64): {String: String} {\n    return NewFunThingPack.getEditionMetadata(edition)\n}","get_is_collection_setup":"import NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport NewFunThing from 0xNewFunThing\nimport NewFunThingPack from 0xNewFunThingPack\n\n\npub fun main(address: Address): Bool {\n    let account = getAccount(address)\n\n    let nftPubPath = NewFunThing.CollectionPublicPath\n    let nftCollection = account.getCapability<&NewFunThing.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,NewFunThing.NewFunThingCollectionPublic,MetadataViews.ResolverCollection}>(nftPubPath).borrow()\n\n    let packPubPath = NewFunThingPack.CollectionPublicPath\n    let packCollection = account.getCapability<&NewFunThingPack.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,NewFunThingPack.PackCollectionPublic,MetadataViews.ResolverCollection}>(packPubPath).borrow()\n\n\n    return nftCollection != nil && packCollection != nil\n}\n","get_owned_NFT_packs":"import NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport NewFunThingPack from 0xNewFunThingPack\n\npub fun main(address: Address): [{String: AnyStruct}] {\n    let account = getAccount(address)\n    let packPubPath = NewFunThingPack.CollectionPublicPath\n    let traitPacksCollection = account.getCapability<&NewFunThingPack.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,NewFunThingPack.PackCollectionPublic,MetadataViews.ResolverCollection}>(packPubPath).borrow()\n    let ownedPacks: [{String: AnyStruct}] = []\n    if (traitPacksCollection == nil) {\n        return ownedPacks\n    }\n    for id in traitPacksCollection!.getIDs() {\n        let traitPack = traitPacksCollection!.borrowPack(id: id)\n        let map: {String: AnyStruct} = {}\n        map[\"id\"] = id\n        map[\"edition\"] = id\n        map[\"packID\"] = traitPack!.packID\n        map[\"packEditionID\"] = traitPack!.packEditionID\n        map[\"editionMetadata\"] = traitPack!.getMetadata()\n        ownedPacks.append(map)\n    }\n    return ownedPacks\n}","get_owned_NFTs":"import NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport NewFunThing from 0xNewFunThing\n\npub fun main(address: Address): [{String: AnyStruct}] {\n    let account = getAccount(address)\n    let tokenPubPath = NewFunThing.CollectionPublicPath\n    let newFunThingsCollection = account.getCapability<&NewFunThing.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,NewFunThing.NewFunThingCollectionPublic,MetadataViews.ResolverCollection}>(tokenPubPath).borrow()\n    let ownedThings: [{String: AnyStruct}] = []\n    if (newFunThingsCollection == nil) {\n        return ownedThings\n    }\n    for id in newFunThingsCollection!.getIDs() {\n        let token = newFunThingsCollection!.borrowNewFunThing(id: id)\n        let map: {String: AnyStruct} = {}\n        map[\"id\"] = id\n        map[\"edition\"] = id\n        map[\"packID\"] = token!.packID\n        map[\"editionMetadata\"] = token!.getMetadata()\n        ownedThings.append(map)\n    }\n    return ownedThings\n}\n"},"vars":{"emulator":{"0xProjectManager":"0xf8d6e0586b0a20c7","0xNewFunThingPack":"0xf8d6e0586b0a20c7","0xNewFunThing":"0xf8d6e0586b0a20c7","0xNonFungibleToken":"0xf8d6e0586b0a20c7","0xMetadataViews":"0xf8d6e0586b0a20c7","0xFungibleToken":"0xee82856bf20e2aa6","0xFlowToken":"0x0ae53cb6e3f42a79"},"testnet":{"0xProjectManager":"0xcbf10523da1a9ee9","0xNewFunThingPack":"0xcbf10523da1a9ee9","0xNewFunThing":"0xcbf10523da1a9ee9","0xNonFungibleToken":"0x631e88ae7f1d7c20","0xMetadataViews":"0x631e88ae7f1d7c20","0xFungibleToken":"0x9a0766d93b6608b7","0xFlowToken":"0x7e60df042a9c0868"},"mainnet":{"0xProjectManager":null,"0xNewFunThingPack":null,"0xNewFunThing":null,"0xNonFungibleToken":"0x1d7e57aa55817448","0xMetadataViews":"0x1d7e57aa55817448","0xFungibleToken":"0xf233dcee88fe0abe","0xFlowToken":"0x1654653399040a61"}}}